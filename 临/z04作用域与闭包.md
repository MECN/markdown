## 作用域与作用域链

讲解作用域前先理解以下概念

- 基础数据类型与引用数据类型
- 内存空间
- 垃圾回收机制
- 执行上下文
- 变量对象与活动对象

### 作用域

- 作用域是指程序源代码中定义变量的区域。
- 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。
- `JavaScript` 采用词法作用域(`lexical scoping`)，也就是静态作用域。
- `JavaScript`中只有全局作用域与函数作用域(因为`eval`我们平时开发中几乎不会用到它，这里不讨论)。 
- 作用域与执行上下文是完全不同的两个概念。 

### 作用域与执行上下文产生的阶段

- `JavaScript`代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。
- 编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段**作用域规则**会确定。
- 执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。 

![17](E:\learn\TC\临\17.png)

**区别：执行上下文在运行时才确定的，根据调用条件随时可能改变；作用域在定义时就确定了，永远不会改变。** 

### 作用域链

先看下执行上下文的生命周期

![15](E:\learn\TC\临\15.png)

函数在调用激活时，会开始创建对应的执行上下文，在执行上下文生成的过程中，变量对象，作用域链，以及`this`的值会分别被确定。 

```javascript
var a = 20;

function test() {
    var b = a + 10;

    function innerTest() {
        var c = 10;
        return b + c;
    }

    return innerTest();
}

test();
```

上面的例子中，全局，函数`test`，函数`innerTest`的执行上下文先后创建。我们设定他们的**变量对象**分别为`VO(global)`，`VO(test)`，` VO(innerTest)`。而`innerTest`的作用域链，则同时包含了这三个**变量对象**，所以`innerTest`的执行上下文可如下表示。

```javascript
innerTestEC = {
    VO: {...},  // 变量对象
    scopeChain: [VO(innerTest), VO(test), VO(global)], // 作用域链
    this:Window
}
```

**当函数调用激活时，进入函数上下文，创建 `VO/AO` 后，就会将活动对象添加到作用链的前端**。 

我们可以直接用一个数组来表示作用域链，数组的第一项`scopeChain[0]`为作用域链的最前端，而数组的最后一项，为作用域链的最末端，所有的最末端都为全局变量对象。 

![18](E:\learn\TC\临\18.png)

因为变量对象在执行上下文进入执行阶段时，就变成了活动对象，因此图中使用了`AO（Active Object ）`来表示。**作用域链就是由一系列变量对象组成的**，我们可以在这个单向通道中，查询变量对象中的标识符，这样就可以访问到上一层作用域中的变量了。 （变量对象和活动对象是处于不同时期的同一个对象）

![20](E:\learn\TC\临\20.png)



 

 

 